/*
 * cl_console_proro.c
 *
 * Created: 12/30/2013 1:09:10 PM
 *  Author: user
 */ 


/**
 * \mainpage Getting Started Application
 *
 * \section Purpose
 *
 * The Getting Started example will help new users get familiar with Atmel's
 * SAM family of microcontrollers. This basic application shows the startup
 * sequence of a chip and how to use its core peripherals.
 *
 * \section Requirements
 *
 * This package can be used with SAM evaluation kits.
 *
 * \section Description
 *
 * The demonstration program makes the LED(s) on the board blink at a fixed rate.
 * This rate is generated by using Time tick timer. The blinking can be stopped
 * using the push button.
 *
 * \section Usage
 *
 * -# Build the program and download it inside the evaluation board.
 * -# On the computer, open and configure a terminal application
 *    (e.g. HyperTerminal on Microsoft Windows) with these settings:
 *   - 115200 bauds
 *   - 8 bits of data
 *   - No parity
 *   - 1 stop bit
 *   - No flow control
 * -# Start the application.
 * -# The LED(s) should start blinking on the board. In the terminal window, the
 *    following text should appear (values depend on the board and chip used):
 *    \code
 *     -- Getting Started Example xxx --
 *     -- xxxxxx-xx
 *     -- Compiled: xxx xx xxxx xx:xx:xx --
 *    \endcode
 * -# Pressing and release button 1 should make one LED stop & restart
 *    blinking.
 * -# If the button 2 available, pressing button 2 should make the other LED
 *    stop & restart blinking.
 *
 */

#include "asf.h"
#include "stdio_serial.h"
#include "conf_board.h"
#include "cl_app/cl_console/inc/cl_consolecontroller.h"
#include "cl_app/cl_mac/inc/cl_mac_controller.h"
#include "conf_clock.h"
#include "inc/cl_console_proto.h" //sanjeer added
#include "cl_app/inc/cl_types.h"
//#include "C:\Users\user\Documents\Atmel Studio\Renalyx\Renalyx_DM1\Renalyx_DM1\src\cl_console\inc\cl_console_callback.h"
#include "cl_app/cl_console/inc/cl_console_callback.h"
Cl_ReturnCodes cl_console_proto_init(void);
Cl_ReturnCodes  Cl_Timer_Create_TimeoutEvent(void);
extern Cl_ReturnCodes 	Cl_MacCheckforConsoleMessage(void);
//extern Cl_ReturnCodes   Cl_SendDatatoconsoleDummycommand(Cl_ConsoleTxCommandtype,uint8_t*,uint8_t);
extern Cl_ReturnCodes Cl_Cosnsole_MsgAcknlowledge(void);
extern Cl_ReturnCodes   Cl_SendDatatoconsoleDummycommand(Cl_ConsoleTxCommandtype,uint8_t*,uint8_t);
extern Cl_ReturnCodes Cl_TimerTickCallback(void);
extern Cl_ReturnCodes cl_systemtickcallback(void);
extern MAC_EVENTS Cl_MacEvent;
extern bool Cl_MacNewEvent;

extern uint8_t loopackflag ;
/** IRQ priority for PIO (The lower the value, the greater the priority) */
#define IRQ_PRIOR_PIO    0

/** LED0 blink time, LED1 blink half this time, in ms */
#define BLINK_PERIOD        1000

#define STRING_EOL    "\r"
#define STRING_HEADER "-- Getting Started Example --\r\n" \
		"-- "BOARD_NAME" --\r\n" \
		"-- Compiled: "__DATE__" "__TIME__" --"STRING_EOL

/** LED0 blinking control. */
volatile bool g_b_led0_active = true;

#ifdef LED1_GPIO
/** LED1 blinking control. */
volatile bool g_b_led1_active = true;

#endif

#ifdef LED0_GPIO
volatile bool g_b_led2_active = true;
#endif

/** Global g_ul_ms_ticks in milliseconds since start of application */


/// @cond 0
/**INDENT-OFF**/
#ifdef __cplusplus
extern "C" {
#endif
/**INDENT-ON**/
/// @endcond

/**
 *  \brief Process Buttons Events
 *
 *  Change active states of LEDs when corresponding button events happened.
 */
 uint8_t temp=0,tempcount,tempcount1=0;
uint32_t rxrdcounter=1;
volatile uint8_t rxdata, copyrxdata ; //added
uint8_t rxbuffer[10];
volatile uint8_t rxbufferptr= 0;
volatile uint8_t rxreadbuffptr = 0;
extern cl_console_msgbufferType Cl_Console_msgbuffer,Cl_Console_buffer1,Cl_Console_buffer2;
extern  uint8_t testbool ;
extern Cl_ConsoleMsgType Cl_ConsoleRxMsg;

extern  int Cl_Rinsesecondscounter  ,Cl_RinseMinutescounter, Cl_Rinseshourscounter;
extern bool Cl_RinseOpenFillTimeOut;
extern cl_console_bufferType Cl_Console_buffer;



//dummy data end

static void ProcessButtonEvt(uint8_t uc_button)
{
	if (uc_button == 0) {
		g_b_led0_active = !g_b_led0_active;
		if (!g_b_led0_active) {
			ioport_set_pin_level(LED0_GPIO, IOPORT_PIN_LEVEL_HIGH);
			
		}
	}
#ifdef LED1_GPIO 
	else {
		g_b_led1_active = !g_b_led1_active;

		/* Enable LED#2 and TC if they were enabled */
		if (g_b_led1_active) {
			ioport_set_pin_level(LED1_GPIO, IOPORT_PIN_LEVEL_LOW);
			tc_start(TC0, 0);
		}
		/* Disable LED#2 and TC if they were disabled */
		else {
			ioport_set_pin_level(LED1_GPIO, IOPORT_PIN_LEVEL_HIGH);
			tc_stop(TC0, 0);
		}
	}
#endif
}

/**
 *  \brief Handler for System Tick interrupt.
 *
 *  Process System Tick Event
 *  Increments the g_ul_ms_ticks counter.
 */
#if 0
void SysTick_Handler(void)
{
	Cl_ReturnCodes RetVal;
	RetVal = cl_systemtickcallback();
}
#endif

/**
 *  \brief Handler for Button 1 rising edge interrupt.
 *
 *  Handle process led1 status change.
 */
static void Button1_Handler(uint32_t id, uint32_t mask)
{
	if (PIN_PUSHBUTTON_1_ID == id && PIN_PUSHBUTTON_1_MASK == mask) {
		ProcessButtonEvt(0);
	}
}

#ifndef BOARD_NO_PUSHBUTTON_2
/**
 *  \brief Handler for Button 2 falling edge interrupt.
 *
 *  Handle process led2 status change.
 */
static void Button2_Handler(uint32_t id, uint32_t mask)
{
	if (PIN_PUSHBUTTON_2_ID == id && PIN_PUSHBUTTON_2_MASK == mask) {
		ProcessButtonEvt(1);
	}
}
#endif

/**
 *  \brief Configure the Pushbuttons
 *
 *  Configure the PIO as inputs and generate corresponding interrupt when
 *  pressed or released.
 */
static void configure_buttons(void)
{
	/* Configure Pushbutton 1 */
	pmc_enable_periph_clk(PIN_PUSHBUTTON_1_ID);
	pio_set_debounce_filter(PIN_PUSHBUTTON_1_PIO, PIN_PUSHBUTTON_1_MASK, 10);
	/* Interrupt on rising edge  */
	pio_handler_set(PIN_PUSHBUTTON_1_PIO, PIN_PUSHBUTTON_1_ID,
			PIN_PUSHBUTTON_1_MASK, PIN_PUSHBUTTON_1_ATTR, Button1_Handler);
	NVIC_EnableIRQ((IRQn_Type) PIN_PUSHBUTTON_1_ID);
	pio_handler_set_priority(PIN_PUSHBUTTON_1_PIO,
			(IRQn_Type) PIN_PUSHBUTTON_1_ID, IRQ_PRIOR_PIO);
	pio_enable_interrupt(PIN_PUSHBUTTON_1_PIO, PIN_PUSHBUTTON_1_MASK);

#ifndef BOARD_NO_PUSHBUTTON_2
	/* Configure Pushbutton 2 */
	pmc_enable_periph_clk(PIN_PUSHBUTTON_2_ID);
	pio_set_debounce_filter(PIN_PUSHBUTTON_2_PIO, PIN_PUSHBUTTON_2_MASK, 10);
	/* Interrupt on falling edge */
	pio_handler_set(PIN_PUSHBUTTON_2_PIO, PIN_PUSHBUTTON_2_ID,
			PIN_PUSHBUTTON_2_MASK, PIN_PUSHBUTTON_2_ATTR, Button2_Handler);
	NVIC_EnableIRQ((IRQn_Type) PIN_PUSHBUTTON_2_ID);
	pio_handler_set_priority(PIN_PUSHBUTTON_2_PIO,
			(IRQn_Type) PIN_PUSHBUTTON_2_ID, IRQ_PRIOR_PIO);
	pio_enable_interrupt(PIN_PUSHBUTTON_2_PIO, PIN_PUSHBUTTON_2_MASK);
#endif
}
void TC1_Handler(void)
{
			
//printf("TC1_Handler\n");
		
		#ifdef LED0_GPIO
		/** Toggle LED state. */
		if (g_b_led0_active) {
		ioport_toggle_pin_level(LED0_GPIO);
		}
		#endif
}
/**
 *  Interrupt handler for TC0 interrupt. Toggles the state of LED\#2.
 */
#if 0
void TC0_Handler(void)
{
	Cl_ReturnCodes  Cl_RetValue;
	volatile uint32_t ul_dummy;
	
	
	Cl_RetValue = Cl_TimerTickCallback();
	 

	//printf("= %d+\n",tempcount1);

	/* Clear status bit to acknowledge interrupt */
	ul_dummy = tc_get_status(TC0, 0);

	/* Avoid compiler warning */
	UNUSED(ul_dummy);

#ifdef LED1_GPIO
	/** Toggle LED state. */
	ioport_toggle_pin_level(LED1_GPIO);
			if (g_b_led0_active) {
			ioport_toggle_pin_level(LED0_GPIO);
		//	printf("1 ");
		}
#endif
	


 	//Cl_RetValue = Cl_MacCheckforConsoleMessage();

		
}

#endif
#if 0
//void USART0_Handler(){
	void UART_Handler()
	{
	
	//uint32_t received_byte;
	//uint32_t dummy = usart_get_interrupt_mask(USART0);
	//ul_status = usart_get_status(USART0);
//	if (ul_status & US_CSR_ENDRX) {
	//	usart_write_line(USART0,"\nUS0H");

	uart_read( CONF_UART, &rxdata);
	//rxbuffer[rxbufferptr]=rxdata;
	//printf("%c", rxdata);
	//uart_write(CONF_UART, rxdata);
	cl_console_copy_buffer_from_uart(rxdata);// this should be routed through SV layer in fact. 
// 	if ((char)rxbuffer[rxbufferptr] == 'F' )
// 	{
// 		//	 printf("KKKK");
// 		
// 	}
//	 if (check_endofsequence_is_received(rxbufferptr))
//	 {
	//	 printf("EOS");
//	 }
	// rxbufferptr++;
	


	}

#endif



/**
 *  Configure Timer Counter 0 to generate an interrupt every 250ms.
 */
static void configure_tc(void)
{
	uint32_t ul_div =0;
	uint32_t ul_tcclks =0;
	uint32_t ul_sysclk = sysclk_get_cpu_hz();

	/* Configure PMC */
	pmc_enable_periph_clk(ID_TC0);

	/** Configure TC for a 4Hz frequency and trigger on RC compare. */
	tc_find_mck_divisor(1, ul_sysclk, &ul_div, &ul_tcclks, ul_sysclk);
	tc_init(TC0, 0, ul_tcclks | TC_CMR_CPCTRG);
	tc_write_rc(TC0, 0, ((ul_sysclk  / ul_div *1 )  ));

	/* Configure and enable interrupt on RC compare */
	NVIC_EnableIRQ((IRQn_Type) ID_TC0);
	tc_enable_interrupt(TC0, 0, TC_IER_CPCS);

#ifdef LED1_GPIO
	/** Start the counter if LED1 is enabled. */
	if (g_b_led1_active) {
		tc_start(TC0, 0);
		
	}
#else
	tc_start(TC0, 0);
#endif
}



/**
 *  Configure Timer Counter 0 to generate an interrupt every 250ms.
 */
static void configure_tc1(void)
{
	uint32_t ul_div;
	uint32_t ul_tcclks;
	uint32_t ul_sysclk = sysclk_get_cpu_hz();

	/* Configure PMC */
	pmc_enable_periph_clk(ID_TC1);

	/** Configure TC for a 4Hz frequency and trigger on RC compare. */
	tc_find_mck_divisor(1, ul_sysclk, &ul_div, &ul_tcclks, ul_sysclk);
	tc_init(TC1, 0, ul_tcclks | TC_CMR_CPCTRG);
	tc_write_rc(TC1, 0, (((ul_sysclk / ul_div) / 1)));

	/* Configure and enable interrupt on RC compare */
	NVIC_EnableIRQ((IRQn_Type) ID_TC1);
	tc_enable_interrupt(TC1, 0, TC_IER_CPCS);

#ifdef LED0_GPIO
	/** Start the counter if LED0 is enabled. */
	if (g_b_led0_active) {
		tc_start(TC1, 1);
	//	printf("TC1 started");
	}
#else
	tc_start(TC1, 1);
#endif
}


/**
 *  Configure UART console.
 */
static void configure_console(void)
{
	const usart_serial_options_t uart_serial_options = {
		.baudrate = CONF_UART_BAUDRATE,
		//.baudrate = 2400,
		.paritytype = CONF_UART_PARITY,
		.stopbits = true
	//.paritytype = UART_MR_PAR_MARK
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONSOLE_UART_ID);
	stdio_serial_init(CONF_UART, &uart_serial_options);
	
	
	uart_disable(CONF_UART);
	uart_enable_rx(CONF_UART);
	
	uart_enable(CONF_UART);

		/* Configure and enable interrupt on RC compare */
		NVIC_EnableIRQ((IRQn_Type) ID_UART);
		uart_enable_interrupt(CONF_UART,UART_IER_RXRDY);   //Interrupt reading ready
		
		


}
/************************************************************************/
/* \brief : Configure Native USB Port                                                                     */
/************************************************************************/




/*************************************************************************/



/**
 * \brief Wait for the given number of milliseconds (using the g_ul_ms_ticks
 * generated by the SAM's microcontrollers's system tick).
 *
 * \param ul_dly_ticks  Delay to wait for, in milliseconds.
 */


/**
 *  \brief getting-started Application entry point.
 *
 *  \return Unused (ANSI-C compatibility).
 */
Cl_ReturnCodes cl_console_proto_init(void)
{
	/* Initialize the SAM system */
	
	//board_init(); // since we have already done the init from cl_mac  main(), we do not need to call it again

	/* Initialize the console uart */
	configure_console();

	/* Output example information */
	//puts(STRING_HEADER);

	/* Configure systick for 1 ms */
	//puts("Configure system tick to get 1ms tick period.\r");
	if (SysTick_Config(sysclk_get_cpu_hz() / 1000)) {
		puts("-F- Systick configuration error\r");
		while (1);
	}

//	puts("Configure TC.\r");
	configure_tc();
	//configure_tc1();

//	puts("Configure buttons with debouncing.\r");
//	configure_buttons();

//	printf("Press %s to Start/Stop the %s blinking.\r\n",
//			PUSHBUTTON_1_NAME, LED_0_NAME);

#ifndef BOARD_NO_PUSHBUTTON_2
//	printf("Press %s to Start/Stop the %s blinking.\r\n",
//			PUSHBUTTON_2_NAME, LED_1_NAME);
#endif
#if 0
	while (1) {
		/* Wait for LED to be active */
		while (!g_b_led0_active);

		/* Toggle LED state if active */
		if (g_b_led0_active) {
			ioport_toggle_pin_level(LED0_GPIO);
		//	printf("1 ");
		}

		/* Wait for 500ms */
		//mdelay(500);
		mdelay(2000);
	}
#endif

//printf("FFFF\n");

return CL_ACCEPTED;
}

/// @cond 0
/**INDENT-OFF**/
#ifdef __cplusplus
}
#endif
/**INDENT-ON**/
/// @endcond


bool  check_endofsequence_is_received(uint8_t rdbufferindex )
{
	uint8_t rdbufferptr ;
	rdbufferptr =  rdbufferindex;
	
	if ((char)Cl_Console_msgbuffer.Console_databuffer[rdbufferptr] == 'F' )
	{
	//	printf("FFF");
		
	
		//	printf("GGGG");
		if(rdbufferptr > 0)
		{
			rdbufferptr-- ;	
		}
		else
		{
			rdbufferptr = CONSOLE_BUFFER_SIZE - 1 ;
		}
	
	if ((char)Cl_Console_msgbuffer.Console_databuffer[rdbufferptr] == 'D' )
	{
	//	printf("DDD");
		
	
			//printf("END \n");
			
			return true;
			
	}
	}
	
	return false;
	
}


bool  check_startofsequence_is_received(uint8_t rdbufferindex )
{
	uint8_t rdbufferptr ;
	rdbufferptr =  rdbufferindex;
	
	if ((char)Cl_Console_msgbuffer.Console_databuffer[rdbufferptr] == 'Q' )
	{
		//printf("FFF");
		
		
		//	printf("GGGG");
	
				if(rdbufferptr > 0)
				{
					rdbufferptr-- ;
				}
				else
				{
					rdbufferptr = CONSOLE_BUFFER_SIZE - 1 ;
				}
		if ((char)Cl_Console_msgbuffer.Console_databuffer[rdbufferptr] == 'X' )
		{
			//printf("DDD");
			
			
			printf("START \n");
			
			return true;
			
		}
	}
	
	return false;
	
}

	 Cl_ReturnCodes  Cl_Timer_Create_TimeoutEvent(void)
	 {
		 Cl_MacEvent = EVT_TIMER_EXPIRED;
		 Cl_MacNewEvent = true;
		 return CL_OK;
		 
		 // Cl_Console_ConvertTimeoutEvent_toMacEvent(Cl_ConsoleRxEventsType command ,MAC_EVENTS* MacEvent)
	 }